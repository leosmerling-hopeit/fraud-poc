# AUTOGENERATED! DO NOT EDIT! File to edit: 08-predict.ipynb (unless otherwise specified).

__all__ = ['OrderInfo', '__steps__', '__api__', 'logger', 'model', 'db', 'features', '__init_event__',
           'lookup_features', 'predict', '__postprocess__']

# Cell
from typing import Dict, Optional
from datetime import datetime, timezone, timedelta
import os
import json
import pickle
import aioredis
import asyncio

import pandas as pd
import numpy as np
import xgboost as xgb
from dataclasses import dataclass
from hopeit.dataobjects import dataobject
from hopeit.server.serialization import serialize, Serialization, deserialize
from hopeit.server.compression import Compression
from hopeit.app.context import EventContext, PostprocessHook
from hopeit.app.events import Spawn, SHUFFLE
from hopeit.app.api import event_api
from hopeit.app.logger import app_logger

# Cell
@dataobject
@dataclass
class OrderInfo:
    order_id: str
    customer_id: str
    order_date: datetime
    email: str
    ip_addr: str
    order_amount: float
    location_lat: float
    location_long: float


# Cell
__steps__ = ['lookup_features', 'predict']

__api__ = event_api(
    title="Live: Predict Fraud",
    payload=(OrderInfo, "Order Information"),
    responses={
        200: (dict, "features used for prediction contatining `is_fraud` field as result of prediction"),
        404: (str, "customer or email not found (this example only works for known customer_id and email)")
    }
)

logger = app_logger()

model = None
db = None

features = ['order_amount',
            'num_email_by_customer_id', 'same_email_by_customer_id', 'known_email_by_customer_id',
            'num_ip_addr_by_customer_id', 'same_ip_addr_by_customer_id', 'known_ip_addr_by_customer_id',
            'num_customer_id_by_email', 'same_customer_id_by_email', 'known_customer_id_by_email',
            'order_amount_mean_by_customer_id',
            'order_amount_std_by_customer_id', 'order_amount_min_by_customer_id', 'order_amount_max_by_customer_id',
            'order_amount_sum_by_customer_id',
            'order_amount_mean_by_email',
            'order_amount_std_by_email', 'order_amount_min_by_email', 'order_amount_max_by_email',
            'order_amount_sum_by_email']

# Cell
async def __init_event__(context: EventContext):
    global model, db
    if model is None:
        file_name = os.path.join(context.env['model']['path'], context.env['model']['name'])
        logger.info(context, f"Loading model for prediction from {file_name}...")
        with open(file_name, 'rb') as fb:
            model = pickle.load(fb)
    if db is None:
        address = context.env['db']['url']
        logger.info(context, f"Connecting to database {address}...")
        db = await aioredis.create_redis_pool(address)


# Cell
async def _lookup_db(key: str):
    item = await db.get(key)
    if item is None:
        return None
    return deserialize(item, Serialization.PICKLE4, Compression.LZ4, dict)

# Cell
async def lookup_features(order: OrderInfo, context: EventContext) -> Optional[dict]:
    logger.info(context, "Looking up features in database...")
    assert db, "Connection to database missing."
    customer_id_features, email_features = await asyncio.gather(
        _lookup_db(order.customer_id),
        _lookup_db(order.email)
    )
    if customer_id_features is None or email_features is None:
        return None
    return {
        **_update_features(order, email_features, 'email'),
        **_update_features(order, customer_id_features, 'customer_id'),
        **order.to_dict()
    }

def _append(data: dict, k: str, new_item: str):
    x = data.get(k)
    if isinstance(x, str):
        x = json.loads(x)
        x.append(new_item)
        data[k] = list(set(x[-10:]))

def _update_features(order: OrderInfo, data: dict, by: str):
    _append(data, f'order_amount_by_{by}', order.order_amount)
    _append(data, f'ip_addr_by_{by}', order.ip_addr)
    _append(data, f'email_by_{by}', order.email)
    _append(data, f'customer_id_by_{by}', order.customer_id)
    _calc_counts(data, 'customer_id')
    _calc_counts(data, 'email')
    _calc_amount_stats(data, 'customer_id')
    _calc_amount_stats(data, 'email')
    return data

def _calc_counts(data: dict, by: str):
    for col in ['ip_addr', 'customer_id', 'email']:
        x = data.get(f'{col}_by_{by}')
        if x is not None:
            data[f'num_{col}_by_{by}'] = len(x)

def _calc_amount_stats(data: dict, by: str):
    col = 'order_amount'
    x = data.get(f'{col}_by_{by}')
    if x is not None:
        x = np.array(x)
        data[f'{col}_max_by_{by}'] = np.max(x)
        data[f'{col}_min_by_{by}'] = np.min(x)
        data[f'{col}_mean_by_{by}'] = np.mean(x)
        data[f'{col}_std_by_{by}'] = np.std(x)
        data[f'{col}_sum_by_{by}'] = np.sum(x)


# Cell
async def predict(data: dict, context: EventContext) -> dict:
    df = pd.DataFrame([data], columns=features)
    x = xgb.DMatrix(df)
    y = model.predict(x)
    data['is_fraud'] = y[0].item()
    return data


# Cell
async def __postprocess__(payload: Optional[dict], context: EventContext, response: PostprocessHook) -> dict:
    if payload is None:
        response.status = 404
        return "customer or email not found (this example only works for known customer_id and email)"
    return payload
